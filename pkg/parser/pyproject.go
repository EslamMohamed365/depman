package parser

import (
	"strings"

	toml "github.com/pelletier/go-toml/v2"
)

// pyprojectData is used for TOML unmarshaling of the relevant sections.
type pyprojectData struct {
	Project struct {
		Dependencies []string `toml:"dependencies"`
	} `toml:"project"`
}

// ParsePyprojectTOML extracts dependencies from a pyproject.toml file.
func ParsePyprojectTOML(content string) []Dep {
	var data pyprojectData
	if err := toml.Unmarshal([]byte(content), &data); err != nil {
		return nil
	}

	var deps []Dep
	for _, entry := range data.Project.Dependencies {
		d := parsePyprojectDep(entry)
		if d.Name != "" {
			deps = append(deps, d)
		}
	}
	return deps
}

// parsePyprojectDep parses a PEP 508 dependency string like "requests==2.31.0".
func parsePyprojectDep(s string) Dep {
	s = strings.TrimSpace(s)
	s = strings.Trim(s, "\"'")

	// Try == first (exact pin)
	if parts := strings.SplitN(s, "==", 2); len(parts) == 2 {
		return Dep{
			Name:    normalizePackageName(parts[0]),
			Version: strings.TrimSpace(parts[1]),
		}
	}

	// Handle other specifiers
	for _, sep := range []string{">=", "<=", "!=", "~=", ">"} {
		if idx := strings.Index(s, sep); idx > 0 {
			return Dep{
				Name:    normalizePackageName(s[:idx]),
				Version: strings.TrimSpace(s[idx+len(sep):]),
			}
		}
	}

	// Package name without version
	return Dep{Name: normalizePackageName(s)}
}

// RewritePyprojectDependencies replaces the [project.dependencies] array in
// a pyproject.toml file while preserving all other content byte-for-byte.
func RewritePyprojectDependencies(originalContent string, deps []Dep) string {
	lines := strings.Split(originalContent, "\n")
	var result []string
	inDeps := false
	depsWritten := false

	for i := 0; i < len(lines); i++ {
		trimmed := strings.TrimSpace(lines[i])

		// Detect the start of dependencies array
		if strings.HasPrefix(trimmed, "dependencies") && strings.Contains(trimmed, "[") {
			inDeps = true
			// Write our replacement
			result = append(result, "dependencies = [")
			result = append(result, "    # Generated by depman")
			for _, d := range deps {
				if d.Version != "" {
					result = append(result, "    \""+d.Name+"=="+d.Version+"\",")
				} else {
					result = append(result, "    \""+d.Name+"\",")
				}
			}
			// If the opening [ and ] are on the same line (inline array)
			if strings.Contains(trimmed, "]") {
				result = append(result, "]")
				inDeps = false
				depsWritten = true
				continue
			}
			depsWritten = true
			continue
		}

		// Skip lines inside the old dependencies array
		if inDeps {
			if strings.Contains(trimmed, "]") {
				result = append(result, "]")
				inDeps = false
			}
			continue
		}

		result = append(result, lines[i])
	}

	// If no dependencies section was found, append one under [project]
	if !depsWritten {
		var finalResult []string
		projectFound := false
		for _, line := range result {
			finalResult = append(finalResult, line)
			if strings.TrimSpace(line) == "[project]" {
				projectFound = true
			}
			// Insert after [project] section header, before next section
			if projectFound && strings.HasPrefix(strings.TrimSpace(line), "[") && strings.TrimSpace(line) != "[project]" {
				insertLines := []string{
					"dependencies = [",
					"    # Generated by depman",
				}
				for _, d := range deps {
					if d.Version != "" {
						insertLines = append(insertLines, "    \""+d.Name+"=="+d.Version+"\",")
					} else {
						insertLines = append(insertLines, "    \""+d.Name+"\",")
					}
				}
				insertLines = append(insertLines, "]", "")
				// Insert before the current section header
				n := len(finalResult)
				last := finalResult[n-1]
				finalResult = finalResult[:n-1]
				finalResult = append(finalResult, insertLines...)
				finalResult = append(finalResult, last)
				projectFound = false // only insert once
			}
		}
		result = finalResult
	}

	return strings.Join(result, "\n")
}

func normalizePackageName(name string) string {
	name = strings.TrimSpace(name)
	// PEP 503: normalize to lowercase, replace .-_ with -
	name = strings.ToLower(name)
	name = strings.ReplaceAll(name, "_", "-")
	return name
}
