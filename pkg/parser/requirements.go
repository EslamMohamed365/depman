package parser

import (
	"bufio"
	"strings"
)

// Dep represents a single dependency entry.
type Dep struct {
	Name    string
	Version string // pinned version, e.g. "1.2.3"
}

// ParseRequirementsTxt parses a requirements.txt file content.
// It extracts package==version entries, skipping comments and blank lines.
func ParseRequirementsTxt(content string) []Dep {
	var deps []Dep
	scanner := bufio.NewScanner(strings.NewReader(content))
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, "-") {
			continue
		}

		// Handle == pinning (most common)
		if parts := strings.SplitN(line, "==", 2); len(parts) == 2 {
			deps = append(deps, Dep{
				Name:    strings.TrimSpace(parts[0]),
				Version: strings.TrimSpace(parts[1]),
			})
			continue
		}

		// Handle >= or other specifiers — extract just the name
		for _, sep := range []string{">=", "<=", "!=", "~=", ">"} {
			if idx := strings.Index(line, sep); idx > 0 {
				deps = append(deps, Dep{
					Name:    strings.TrimSpace(line[:idx]),
					Version: strings.TrimSpace(line[idx+len(sep):]),
				})
				break
			}
		}

		// Plain package name without version
		if !strings.ContainsAny(line, "=<>!~") {
			deps = append(deps, Dep{Name: line})
		}
	}
	return deps
}

// FormatRequirementsTxt formats a list of dependencies as requirements.txt content.
func FormatRequirementsTxt(deps []Dep) string {
	var b strings.Builder
	b.WriteString("# Generated by depman — do not edit manually\n")
	for _, d := range deps {
		if d.Version != "" {
			b.WriteString(d.Name + "==" + d.Version + "\n")
		} else {
			b.WriteString(d.Name + "\n")
		}
	}
	return b.String()
}
